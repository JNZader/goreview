import { loadRepoConfig } from '../config/repoConfig.js';
import { logger } from '../utils/logger.js';
import { getPreviousStatus, buildHandoffStatus, generateHandoffBlock, } from './statusLine.js';
const SEVERITY_ORDER = ['info', 'warning', 'error', 'critical'];
/**
 * Service for posting review comments to GitHub.
 */
export class CommentService {
    /**
     * Post review results to a pull request.
     */
    async postReview(octokit, owner, repo, pullNumber, result) {
        const repoConfig = await loadRepoConfig(octokit, owner, repo);
        const options = repoConfig.comments;
        // Get previous review status for handoff
        const previousStatus = await getPreviousStatus(octokit, owner, repo, pullNumber);
        // Build handoff status with detailed tracking
        const handoffResult = this.convertToHandoffResult(result);
        const currentStatus = buildHandoffStatus(handoffResult, previousStatus);
        logger.info({
            owner, repo, pullNumber,
            round: currentStatus.reviewRound,
            resolved: currentStatus.resolvedIssues,
            persistent: currentStatus.persistentIssues,
        }, 'Handoff status calculated');
        // Filter issues by severity
        const minSeverityIndex = SEVERITY_ORDER.indexOf(options.min_severity);
        const filteredFiles = result.files.map(file => ({
            ...file,
            issues: file.issues.filter(issue => SEVERITY_ORDER.indexOf(issue.severity) >= minSeverityIndex),
        }));
        const totalFilteredIssues = filteredFiles.reduce((sum, f) => sum + f.issues.length, 0);
        // Determine review event type
        let event = 'COMMENT';
        if (totalFilteredIssues === 0) {
            event = 'APPROVE';
        }
        else if (options.request_changes && result.criticalIssues > 0) {
            event = 'REQUEST_CHANGES';
        }
        // Build review body with handoff information
        const body = this.buildReviewBody(result, filteredFiles, currentStatus, previousStatus);
        // Build inline comments
        const comments = options.inline
            ? this.buildInlineComments(filteredFiles)
            : [];
        // Create the review
        try {
            await octokit.pulls.createReview({
                owner,
                repo,
                pull_number: pullNumber,
                event,
                body,
                comments,
            });
            logger.info({
                owner, repo, pullNumber,
                event,
                commentCount: comments.length,
            }, 'Posted review to PR');
        }
        catch (error) {
            logger.error({ error, owner, repo, pullNumber }, 'Failed to post review');
            throw error;
        }
        // Add labels if configured
        if (repoConfig.labels.add_on_issues && result.criticalIssues > 0) {
            await this.addLabel(octokit, owner, repo, pullNumber, repoConfig.labels.critical);
        }
        if (repoConfig.labels.add_on_issues) {
            await this.addLabel(octokit, owner, repo, pullNumber, repoConfig.labels.reviewed);
        }
    }
    buildReviewBody(result, filteredFiles, currentStatus, previousStatus) {
        // Consolidate initial push calls into array initialization
        const lines = [
            // Handoff status block (includes embedded data for next round)
            generateHandoffBlock(currentStatus, previousStatus),
            '',
            // Header
            '## AI Code Review',
            '',
            // Summary stats
            `**Files reviewed:** ${result.filesReviewed}`,
            `**Issues found:** ${result.totalIssues}`,
            `**Overall score:** ${result.overallScore}/100`,
            '',
            // Main summary
            result.summary,
            '',
        ];
        // Issue breakdown by severity
        const severityCounts = {};
        for (const file of filteredFiles) {
            for (const issue of file.issues) {
                severityCounts[issue.severity] = (severityCounts[issue.severity] || 0) + 1;
            }
        }
        if (Object.keys(severityCounts).length > 0) {
            lines.push('### Issue Summary', '', '| Severity | Count |', '|----------|-------|');
            for (const severity of [...SEVERITY_ORDER].reverse()) {
                const count = severityCounts[severity];
                if (count) {
                    const emoji = this.getSeverityEmoji(severity);
                    lines.push(`| ${emoji} ${severity} | ${count} |`);
                }
            }
            lines.push('');
        }
        // Footer
        lines.push('---', '*Generated by AI Code Review*');
        return lines.join('\n');
    }
    /**
     * Convert PRReviewResult to the format expected by buildHandoffStatus.
     */
    convertToHandoffResult(result) {
        return {
            score: result.overallScore,
            totalIssues: result.totalIssues,
            criticalIssues: result.criticalIssues,
            files: result.files.map(f => ({
                path: f.path,
                issues: f.issues.map(i => ({
                    severity: i.severity,
                    type: i.type,
                    message: i.message,
                    line: i.line,
                })),
            })),
        };
    }
    buildInlineComments(files) {
        // Use flatMap to consolidate array building instead of push in loop
        return files.flatMap((file) => file.issues
            .filter((issue) => issue.line && issue.line > 0)
            .map((issue) => ({
            path: file.path,
            line: issue.line,
            body: this.formatIssueComment(issue),
        })));
    }
    formatIssueComment(issue) {
        const emoji = this.getSeverityEmoji(issue.severity);
        const lines = [`${emoji} **${issue.severity.toUpperCase()}**: ${issue.message}`];
        if (issue.suggestion) {
            lines.push('', `**Suggestion:** ${issue.suggestion}`);
        }
        return lines.join('\n');
    }
    getSeverityEmoji(severity) {
        switch (severity) {
            case 'critical': return ':rotating_light:';
            case 'error': return ':x:';
            case 'warning': return ':warning:';
            case 'info': return ':information_source:';
            default: return ':grey_question:';
        }
    }
    async addLabel(octokit, owner, repo, pullNumber, label) {
        try {
            await octokit.issues.addLabels({
                owner,
                repo,
                issue_number: pullNumber,
                labels: [label],
            });
        }
        catch (error) {
            logger.warn({ error, label }, 'Failed to add label');
        }
    }
}
export const commentService = new CommentService();
//# sourceMappingURL=commentService.js.map