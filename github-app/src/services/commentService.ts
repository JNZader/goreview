import { Octokit } from '@octokit/rest';
import { PRReviewResult, FileReviewResult } from './reviewService.js';
import { ReviewIssue } from './ai/index.js';
import { loadRepoConfig } from '../config/repoConfig.js';
import { logger } from '../utils/logger.js';
import {
  getPreviousStatus,
  buildHandoffStatus,
  generateHandoffBlock,
  ReviewStatus,
} from './statusLine.js';

export interface CommentOptions {
  inline: boolean;
  summary: boolean;
  requestChanges: boolean;
  minSeverity: 'info' | 'warning' | 'error' | 'critical';
}

const SEVERITY_ORDER = ['info', 'warning', 'error', 'critical'];

/**
 * Service for posting review comments to GitHub.
 */
export class CommentService {
  /**
   * Post review results to a pull request.
   */
  async postReview(
    octokit: Octokit,
    owner: string,
    repo: string,
    pullNumber: number,
    result: PRReviewResult
  ): Promise<void> {
    const repoConfig = await loadRepoConfig(octokit, owner, repo);
    const options = repoConfig.comments;

    // Get previous review status for handoff
    const previousStatus = await getPreviousStatus(octokit, owner, repo, pullNumber);

    // Build handoff status with detailed tracking
    const handoffResult = this.convertToHandoffResult(result);
    const currentStatus = buildHandoffStatus(handoffResult, previousStatus);

    logger.info({
      owner, repo, pullNumber,
      round: currentStatus.reviewRound,
      resolved: currentStatus.resolvedIssues,
      persistent: currentStatus.persistentIssues,
    }, 'Handoff status calculated');

    // Filter issues by severity
    const minSeverityIndex = SEVERITY_ORDER.indexOf(options.min_severity);

    const filteredFiles = result.files.map(file => ({
      ...file,
      issues: file.issues.filter(issue =>
        SEVERITY_ORDER.indexOf(issue.severity) >= minSeverityIndex
      ),
    }));

    const totalFilteredIssues = filteredFiles.reduce(
      (sum, f) => sum + f.issues.length, 0
    );

    // Determine review event type
    let event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT' = 'COMMENT';

    if (totalFilteredIssues === 0) {
      event = 'APPROVE';
    } else if (options.request_changes && result.criticalIssues > 0) {
      event = 'REQUEST_CHANGES';
    }

    // Build review body with handoff information
    const body = this.buildReviewBody(result, filteredFiles, currentStatus, previousStatus);

    // Build inline comments
    const comments = options.inline
      ? this.buildInlineComments(filteredFiles)
      : [];

    // Create the review
    try {
      await octokit.pulls.createReview({
        owner,
        repo,
        pull_number: pullNumber,
        event,
        body,
        comments,
      });

      logger.info({
        owner, repo, pullNumber,
        event,
        commentCount: comments.length,
      }, 'Posted review to PR');
    } catch (error) {
      logger.error({ error, owner, repo, pullNumber }, 'Failed to post review');
      throw error;
    }

    // Add labels if configured
    if (repoConfig.labels.add_on_issues && result.criticalIssues > 0) {
      await this.addLabel(octokit, owner, repo, pullNumber, repoConfig.labels.critical);
    }

    if (repoConfig.labels.add_on_issues) {
      await this.addLabel(octokit, owner, repo, pullNumber, repoConfig.labels.reviewed);
    }
  }

  private buildReviewBody(
    result: PRReviewResult,
    filteredFiles: FileReviewResult[],
    currentStatus: ReviewStatus,
    previousStatus: Partial<ReviewStatus> | null
  ): string {
    // Consolidate initial push calls into array initialization
    const lines: string[] = [
      // Handoff status block (includes embedded data for next round)
      generateHandoffBlock(currentStatus, previousStatus),
      '',
      // Header
      '## AI Code Review',
      '',
      // Summary stats
      `**Files reviewed:** ${result.filesReviewed}`,
      `**Issues found:** ${result.totalIssues}`,
      `**Overall score:** ${result.overallScore}/100`,
      '',
      // Main summary
      result.summary,
      '',
    ];

    // Issue breakdown by severity
    const severityCounts: Record<string, number> = {};
    for (const file of filteredFiles) {
      for (const issue of file.issues) {
        severityCounts[issue.severity] = (severityCounts[issue.severity] || 0) + 1;
      }
    }

    if (Object.keys(severityCounts).length > 0) {
      lines.push('### Issue Summary', '', '| Severity | Count |', '|----------|-------|');

      for (const severity of [...SEVERITY_ORDER].reverse()) {
        const count = severityCounts[severity];
        if (count) {
          const emoji = this.getSeverityEmoji(severity);
          lines.push(`| ${emoji} ${severity} | ${count} |`);
        }
      }
      lines.push('');
    }

    // Footer
    lines.push('---', '*Generated by AI Code Review*');

    return lines.join('\n');
  }

  /**
   * Convert PRReviewResult to the format expected by buildHandoffStatus.
   */
  private convertToHandoffResult(result: PRReviewResult): {
    score: number;
    totalIssues: number;
    criticalIssues: number;
    files: Array<{
      path: string;
      issues: Array<{
        severity: string;
        type: string;
        message: string;
        line?: number;
      }>;
    }>;
  } {
    return {
      score: result.overallScore,
      totalIssues: result.totalIssues,
      criticalIssues: result.criticalIssues,
      files: result.files.map(f => ({
        path: f.path,
        issues: f.issues.map(i => ({
          severity: i.severity,
          type: i.type,
          message: i.message,
          line: i.line,
        })),
      })),
    };
  }

  private buildInlineComments(
    files: FileReviewResult[]
  ): Array<{
    path: string;
    line: number;
    body: string;
  }> {
    // Use flatMap to consolidate array building instead of push in loop
    return files.flatMap((file) =>
      file.issues
        .filter((issue) => issue.line && issue.line > 0)
        .map((issue) => ({
          path: file.path,
          line: issue.line!,
          body: this.formatIssueComment(issue),
        }))
    );
  }

  private formatIssueComment(issue: ReviewIssue): string {
    const emoji = this.getSeverityEmoji(issue.severity);
    const lines = [`${emoji} **${issue.severity.toUpperCase()}**: ${issue.message}`];

    if (issue.suggestion) {
      lines.push('', `**Suggestion:** ${issue.suggestion}`);
    }

    return lines.join('\n');
  }

  private getSeverityEmoji(severity: string): string {
    switch (severity) {
      case 'critical': return ':rotating_light:';
      case 'error': return ':x:';
      case 'warning': return ':warning:';
      case 'info': return ':information_source:';
      default: return ':grey_question:';
    }
  }

  private async addLabel(
    octokit: Octokit,
    owner: string,
    repo: string,
    pullNumber: number,
    label: string
  ): Promise<void> {
    try {
      await octokit.issues.addLabels({
        owner,
        repo,
        issue_number: pullNumber,
        labels: [label],
      });
    } catch (error) {
      logger.warn({ error, label }, 'Failed to add label');
    }
  }
}

export const commentService = new CommentService();
